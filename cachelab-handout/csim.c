//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <assert.h>
#include <errno.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// ------------------------ Structures ------------------------

// struct _IO_FILE {
//     int32_t e0;
// };

// ------------------- Function Prototypes --------------------

// int64_t __do_global_dtors_aux(void);
// int64_t __libc_csu_fini(void);
// int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3);
// int64_t _fini(void);
// int64_t _init(void);
// int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
void accessData(int64_t addr);
void correctTrans(int32_t M, uint32_t N, int32_t (*A)[1], int32_t (*B2)[1]);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void freeCache(void);
void function_a10(int64_t * ptr);
int32_t function_a20(int32_t c);
int32_t * function_a30(void);
int32_t function_a40(char * s2);
int32_t function_a50(struct _IO_FILE * stream);
void function_a60(void);
int32_t function_a70(char * format, ...);
void function_a80(char * assertion, char * file, int32_t line, char * function);
void function_a90(int32_t seed);
char * function_aa0(char * s2, int32_t n, struct _IO_FILE * stream);
int32_t function_ab0(struct _IO_FILE * stream, char * format, ...);
int32_t function_ac0(int32_t * timer);
int64_t * function_ad0(int32_t size);
int32_t function_ae0(char * s2, char * format, ...);
struct _IO_FILE * function_af0(char * filename, char * modes);
int32_t function_b00(int32_t argc, char ** argv, char * shortopts);
int32_t function_b10(char * nptr);
void function_b20(int32_t status);
char * function_b30(int32_t errnum);
int32_t function_b40(void);
void function_b50(int64_t * d);
void initCache(void);
void initMatrix(int32_t M, uint32_t N, int32_t (*A)[1], int32_t (*B2)[1]);
void printSummary(uint32_t hits, uint32_t misses, uint32_t evictions);
void printUsage(char ** argv);
void randMatrix(int32_t M, uint32_t N, int32_t (*A)[1]);
int64_t register_tm_clones(void);
void registerTransFunction(void (*trans)(int32_t, int32_t, int32_t (*)[1], int32_t (*)[1]), char * desc);
void replayTrace(char * trace_fn);

// --------------------- Global Variables ---------------------

int32_t B = 0; // 0x203078
int32_t E = 0; // 0x20305c
int32_t S = 0; // 0x203088
int32_t b = 0; // 0x203058
int64_t cache = 0; // 0x203080
int32_t eviction_count = 0; // 0x203070
int32_t func_counter = 0; // 0x203074
int64_t func_list = 0; // 0x2030a0
int32_t g1 = -1976; // 0x1b2c
int64_t g2 = 3168; // 0x202d20
int64_t g3 = 3104; // 0x202d28
struct _IO_FILE * g4 = NULL; // 0x203040
char g5 = 0; // 0x203048
int64_t g6 = 0; // 0x2030a8
int64_t g7 = 0; // 0x2030b0
int64_t g8 = 0; // 0x2030b4
int64_t g9 = 0; // 0x2030b8
int64_t g10 = 0; // 0x2030bc
int32_t g11 = 0; // 0x3e8
int32_t hit_count = 0; // 0x20306c
int64_t lru_counter = 1; // 0x203010
int32_t miss_count = 0; // 0x203068
int32_t s = 0; // 0x203054
int64_t set_index_mask = 0; // 0x203090
int64_t trace_file = 0; // 0x203060
int32_t g12;
int32_t verbosity = 0; // 0x203050

// ------------------------ Functions -------------------------

// // Address range: 0x9e0 - 0x9f7
// int64_t _init(void) {
//     int64_t result = 0; // 0x9ee
//     if (*(int64_t *)0x202fe8 != 0) {
//         // 0x9f0
//         __gmon_start__();
//         result = &g12;
//     }
//     // 0x9f2
//     return result;
// }

// Address range: 0xa10 - 0xa16
void function_a10(int64_t * ptr) {
    // 0xa10
    free(ptr);
}

// Address range: 0xa20 - 0xa26
int32_t function_a20(int32_t c) {
    // 0xa20
    return putchar(c);
}

// Address range: 0xa30 - 0xa36
int32_t * function_a30(void) {
    // 0xa30
    return __errno_location();
}

// Address range: 0xa40 - 0xa46
int32_t function_a40(char * s2) {
    // 0xa40
    return puts(s2);
}

// Address range: 0xa50 - 0xa56
int32_t function_a50(struct _IO_FILE * stream) {
    // 0xa50
    return fclose(stream);
}

// Address range: 0xa60 - 0xa66
void function_a60(void) {
    // 0xa60
    __stack_chk_fail();
}

// Address range: 0xa70 - 0xa76
int32_t function_a70(char * format, ...) {
    // 0xa70
    return printf(format);
}

// Address range: 0xa80 - 0xa86
void function_a80(char * assertion, char * file, int32_t line, char * function) {
    // 0xa80
    __assert_fail(assertion, file, line, function);
}

// Address range: 0xa90 - 0xa96
void function_a90(int32_t seed) {
    // 0xa90
    srand(seed);
}

// Address range: 0xaa0 - 0xaa6
char * function_aa0(char * s2, int32_t n, struct _IO_FILE * stream) {
    // 0xaa0
    return fgets(s2, n, stream);
}

// Address range: 0xab0 - 0xab6
int32_t function_ab0(struct _IO_FILE * stream, char * format, ...) {
    // 0xab0
    return fprintf(stream, format);
}

// Address range: 0xac0 - 0xac6
int32_t function_ac0(int32_t * timer) {
    // 0xac0
    return time(timer);
}

// Address range: 0xad0 - 0xad6
int64_t * function_ad0(int32_t size) {
    // 0xad0
    return malloc(size);
}

// Address range: 0xae0 - 0xae6
int32_t function_ae0(char * s2, char * format, ...) {
    // 0xae0
    return sscanf(s2, format);
}

// Address range: 0xaf0 - 0xaf6
struct _IO_FILE * function_af0(char * filename, char * modes) {
    // 0xaf0
    return fopen(filename, modes);
}

// Address range: 0xb00 - 0xb06
int32_t function_b00(int32_t argc, char ** argv, char * shortopts) {
    // 0xb00
    return getopt(argc, argv, shortopts);
}

// Address range: 0xb10 - 0xb16
int32_t function_b10(char * nptr) {
    // 0xb10
    return atoi(nptr);
}

// Address range: 0xb20 - 0xb26
void function_b20(int32_t status) {
    // 0xb20
    exit(status);
}

// Address range: 0xb30 - 0xb36
char * function_b30(int32_t errnum) {
    // 0xb30
    return strerror(errnum);
}

// Address range: 0xb40 - 0xb46
int32_t function_b40(void) {
    // 0xb40
    return rand();
}

// Address range: 0xb50 - 0xb56
void function_b50(int64_t * d) {
    // 0xb50
    __cxa_finalize(d);
}

// Address range: 0xb60 - 0xb8b
// int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
//     // 0xb60
//     int64_t v1; // 0xb60
//     __libc_start_main(0x1316, (int32_t)a4, (char **)&v1, (void (*)())0x18a0, (void (*)())0x1910, (void (*)())a3);
//     __asm_hlt();
//     // UNREACHABLE
// }

// Address range: 0xb90 - 0xbc2
int64_t deregister_tm_clones(void) {
    // 0xb90
    return 0x203018;
}

// Address range: 0xbd0 - 0xc12
int64_t register_tm_clones(void) {
    // 0xbd0
    return 0;
}

// Address range: 0xc20 - 0xc5a
// int64_t __do_global_dtors_aux(void) {
//     // 0xc20
//     if (g5 != 0) {
//         // 0xc58
//         int64_t result; // 0xc20
//         return result;
//     }
//     // 0xc29
//     if (*(int64_t *)0x202ff8 != 0) {
//         // 0xc37
//         __cxa_finalize((int64_t *)*(int64_t *)0x203008);
//     }
//     int64_t result2 = deregister_tm_clones(); // 0xc43
//     g5 = 1;
//     return result2;
// }

// Address range: 0xc60 - 0xc6a
int64_t frame_dummy(void) {
    // 0xc60
    return register_tm_clones();
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/csim-ref.c
// Address range: 0xc6a - 0xdc4
// Line range:    71 - 86
void initCache(void) {
    int64_t mem = (int64_t)malloc(8 * S); // 0xc82
    cache = mem;
    if (S != 0) {
        int32_t v1 = 0; // 0xd8c
        int64_t v2 = 0; // 0xcc0
        *(int64_t *)(v2 + mem) = (int64_t)malloc(24 * E);
        int32_t v3 = 0; // 0xd86
        int32_t v4; // 0xc6a
        int64_t v5; // 0xd05
        int32_t v6; // 0xd79
        int64_t v7; // 0xd86
        if (E != 0) {
            v5 = 0;
            *(char *)(*(int64_t *)(cache + v2) + v5) = 0;
            *(int64_t *)(v5 + 8 + *(int64_t *)(cache + v2)) = 0;
            *(int64_t *)(v5 + 16 + *(int64_t *)(cache + v2)) = 0;
            v6 = 1;
            v7 = v6;
            v4 = v6;
            v3 = E;
            while (v7 < (int64_t)E) {
                // 0xcdf
                v5 = 24 * v7;
                *(char *)(*(int64_t *)(cache + v2) + v5) = 0;
                *(int64_t *)(v5 + 8 + *(int64_t *)(cache + v2)) = 0;
                *(int64_t *)(v5 + 16 + *(int64_t *)(cache + v2)) = 0;
                v6 = v4 + 1;
                v7 = v6;
                v4 = v6;
                v3 = E;
            }
        }
        // 0xd8c
        v1++;
        int64_t v8 = v1; // 0xd99
        while (v8 < (int64_t)S) {
            // 0xd8c
            v2 = 8 * v8;
            *(int64_t *)(v2 + cache) = (int64_t)malloc(24 * v3);
            v3 = 0;
            if (E != 0) {
                v5 = 0;
                *(char *)(*(int64_t *)(cache + v2) + v5) = 0;
                *(int64_t *)(v5 + 8 + *(int64_t *)(cache + v2)) = 0;
                *(int64_t *)(v5 + 16 + *(int64_t *)(cache + v2)) = 0;
                v6 = 1;
                v7 = v6;
                v4 = v6;
                v3 = E;
                while (v7 < (int64_t)E) {
                    // 0xcdf
                    v5 = 24 * v7;
                    *(char *)(*(int64_t *)(cache + v2) + v5) = 0;
                    *(int64_t *)(v5 + 8 + *(int64_t *)(cache + v2)) = 0;
                    *(int64_t *)(v5 + 16 + *(int64_t *)(cache + v2)) = 0;
                    v6 = v4 + 1;
                    v7 = v6;
                    v4 = v6;
                    v3 = E;
                }
            }
            // 0xd8c
            v1++;
            v8 = v1;
        }
    }
    uint32_t v9 = s % 32; // 0xdac
    int64_t v10 = 0; // 0xdac
    if (v9 != 0) {
        v10 = -1 - (-1 << v9);
    }
    set_index_mask = v10;
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/csim-ref.c
// Address range: 0xdc4 - 0xe15
// Line range:    92 - 99
void freeCache(void) {
    int32_t v1 = 0; // 0xe01
    if (S == 0) {
        // 0xe03
        free((int64_t *)cache);
        return;
    }
    free((int64_t *)*(int64_t *)cache);
    v1++;
    int64_t v2 = v1; // 0xe01
    int64_t v3 = cache;
    int64_t v4 = v3; // 0xe01
    while (v2 < (int64_t)S) {
        // 0xdd5
        free((int64_t *)*(int64_t *)(8 * v2 + v3));
        v1++;
        v2 = v1;
        v3 = cache;
        v4 = v3;
    }
    // 0xe03
    free((int64_t *)v4);
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/csim-ref.c
// Address range: 0xe15 - 0x10a4
// Line range:    108 - 147
void accessData(int64_t addr) {
    uint32_t v1 = b; // 0xe30
    uint64_t v2 = 0x100000000 * addr / 0x100000000; // 0xe36
    int64_t v3 = v2 >> (int64_t)((s + v1) % 64);
    int64_t v4 = *(int64_t *)(8 * (v2 >> (int64_t)(v1 % 64) & set_index_mask) + cache); // 0xe7d
    int64_t v5; // 0xeaa
    if (E != 0) {
        int64_t v6 = 0; // 0xf41
        v5 = 24 * v6 + v4;
        if (v3 == *(int64_t *)(v5 + 8)) {
            // 0xebb
            if (*(char *)v5 != 0) {
                // 0xedf
                hit_count++;
                if (verbosity == 0) {
                    goto lab_0xf09;
                } else {
                    // 0xef8
                    printf("hit ");
                    goto lab_0xf09;
                }
            }
        }
        // 0xf41
        v6 = (0x100000000 * v6 + 0x100000000) / 0x100000000;
        while (v6 < (int64_t)E) {
            // 0xe90
            v5 = 24 * v6 + v4;
            if (v3 == *(int64_t *)(v5 + 8)) {
                // 0xebb
                if (*(char *)v5 != 0) {
                    // 0xedf
                    hit_count++;
                    if (verbosity == 0) {
                        goto lab_0xf09;
                    } else {
                        // 0xef8
                        printf("hit ");
                        goto lab_0xf09;
                    }
                }
            }
            // 0xf41
            v6 = (0x100000000 * v6 + 0x100000000) / 0x100000000;
        }
    }
    // 0xf54
    miss_count++;
    int32_t v7 = E; // 0xf6b
    if (verbosity != 0) {
        // 0xf6d
        printf("miss ");
        v7 = E;
    }
    int64_t v8 = 0; // 0xfe6
    if (v7 != 0) {
        int64_t v9 = 0; // 0xfd9
        uint64_t v10 = -1;
        uint64_t v11 = *(int64_t *)(v4 + 16 + 24 * v9); // 0xfa4
        int64_t v12 = v10 > v11 ? v9 : 0;
        v9 = (0x100000000 * v9 + 0x100000000) / 0x100000000;
        int64_t v13 = v10 > v11 ? v11 : v10; // 0xfe6
        int64_t v14 = v12; // 0xfe6
        while (v9 < (int64_t)v7) {
            // 0xf87
            v10 = v13;
            v11 = *(int64_t *)(v4 + 16 + 24 * v9);
            v12 = v10 > v11 ? v9 : v14;
            v9 = (0x100000000 * v9 + 0x100000000) / 0x100000000;
            v13 = v10 > v11 ? v11 : v10;
            v14 = v12;
        }
        // 0xfdd
        v8 = 24 * (v12 & 0xffffffff);
    }
    int64_t v15 = v8 + v4; // 0xfff
    char * v16 = (char *)v15; // 0x1002
    if (*v16 != 0) {
        // 0x1009
        eviction_count++;
        if (verbosity != 0) {
            // 0x1022
            printf("eviction ");
        }
    }
    // 0x1033
    *v16 = 1;
    *(int64_t *)(v15 + 8) = v3;
    int64_t v17 = lru_counter; // 0x1072
    lru_counter = v17 + 1;
    *(int64_t *)(v15 + 16) = v17;
  lab_0xf09:;
    int64_t v18 = lru_counter; // 0xf09
    lru_counter = v18 + 1;
    *(int64_t *)(v5 + 16) = v18;
    return;
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/csim-ref.c
// Address range: 0x10a4 - 0x124f
// Line range:    153 - 184
void replayTrace(char * trace_fn) {
    char buf2[1000]; // bp-1024, 0x10a4
    char buf[1000]; // bp-1032, 0x10a4
    char v1[1000]; // 0x10f0
    // int64_t v2 = __readfsqword(40); // 0x10b6
    memset(buf, 0, sizeof(buf));
    int32_t v3 = 0; // bp-1036, 0x10d0
    struct _IO_FILE * file = fopen(trace_fn, "r"); // 0x10eb
    v1[0] = (int64_t)file;
    memcpy(buf2, v1, sizeof(v1));
    int64_t v4 = *(int64_t *)&buf2; // 0x10f7
    if (v4 == 0) {
        // 0x1105
        fprintf(g4, "%s: %s\n", trace_fn, strerror(*__errno_location()));
        exit(1);
        // UNREACHABLE
    }
    struct _IO_FILE * stream = (struct _IO_FILE *)v4;
    int64_t str; // bp-1016, 0x10a4
    char v5; // 0x10a4
    if (fgets((char *)&str, (int32_t)&g11, stream) != NULL) {
        while (true) {
          lab_0x1142:
            switch (v5) {
                case 83: {
                    goto lab_0x1167;
                }
                case 76: {
                    goto lab_0x1167;
                }
                default: {
                    if (v5 != 77) {
                        goto lab_0x1205;
                    } else {
                        goto lab_0x1167;
                    }
                }
            }
        }
    }
  lab_0x1229:
    // 0x1229
    fclose(stream);
    // if (v2 != __readfsqword(40)) {
    //     // 0x1248
    //     __stack_chk_fail();
    // }
  lab_0x1167:;
    // 0x1167
    int64_t str2; // bp-1013, 0x10a4
    sscanf((char *)&str2, "%llx,%u", &buf, &v3);
    if (verbosity != 0) {
        // 0x119e
        printf("%c %llx,%u ", v5, *(int64_t *)&buf, v3);
    }
    // 0x11c8
    accessData(*(int64_t *)&buf);
    if (v5 == 77) {
        // 0x11e2
        accessData(*(int64_t *)&buf);
    }
    // 0x11f1
    if (verbosity != 0) {
        // 0x11fb
        putchar(10);
    }
    goto lab_0x1205;
  lab_0x1205:
    // 0x1205
    if (fgets((char *)&str, (int32_t)&g11, stream) == NULL) {
        // break -> 0x1229
        goto lab_0x1229;
    }
    goto lab_0x1142;
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/csim-ref.c
// Address range: 0x124f - 0x1316
// Line range:    189 - 202
void printUsage(char ** argv) {
    // 0x124f
    printf("Usage: %s [-hv] -s <num> -E <num> -b <num> -t <file>\n", argv);
    puts("Options:");
    puts("  -h         Print this help message.");
    puts("  -v         Optional verbose flag.");
    puts("  -s <num>   Number of set index bits.");
    puts("  -E <num>   Number of lines per set.");
    puts("  -b <num>   Number of block offset bits.");
    puts("  -t <file>  Trace file.");
    puts("\nExamples:");
    printf("  linux>  %s -s 4 -E 1 -b 4 -t traces/yi.trace\n", "\nExamples:");
    printf("  linux>  %s -v -s 8 -E 2 -b 4 -t traces/yi.trace\n", "  linux>  %s -s 4 -E 1 -b 4 -t traces/yi.trace\n");
    exit(0);
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/csim-ref.c
// Address range: 0x1316 - 0x14dd
// Line range:    208 - 265
int main(int argc, char ** argv) {
    int32_t v1 = getopt(argc, argv, "s:E:b:t:vh"); // 0x13fd
    if ((char)v1 != -1) {
        int32_t v2 = 0x1000000 * v1;
        uint32_t v3 = v2 / 0x1000000 - 69; // 0x132e
        if (v2 == 0x76000000 || v3 < 49) {
            int32_t v4 = *(int32_t *)(4 * (int64_t)v3 + (int64_t)&g1); // 0x134b
            return v4 + (int32_t)&g1;
        }
        // 0x13d4
        printUsage(argv);
        // UNREACHABLE
    }
    // 0x140f
    if (s == 0 || E == 0 || b == 0 || trace_file == 0) {
        // 0x1439
        printf("%s: Missing required command line argument\n", argv);
        printUsage(argv);
        // UNREACHABLE
    }
    // 0x146a
    S = 1 << s % 32;
    B = 1 << b % 32;
    initCache();
    replayTrace((char *)trace_file);
    freeCache();
    printSummary(hit_count, miss_count, eviction_count);
    return 0;
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/cachelab.c
// Address range: 0x14dd - 0x157a
// Line range:    18 - 25
void printSummary(uint32_t hits, uint32_t misses, uint32_t evictions) {
    int64_t v1 = misses;
    int64_t v2 = evictions; // 0x14ee
    int64_t v3 = hits; // 0x14f7
    printf("hits:%d misses:%d evictions:%d\n", v3, v1, v2);
    struct _IO_FILE * file = fopen(".csim_results", "w"); // 0x1518
    if (file == NULL) {
        // 0x1528
        __assert_fail("output_fp", "cachelab.c", 22, "printSummary");
    }
    // 0x1547
    fprintf(file, "%d %d %d\n", v3, v1, v2);
    fclose(file);
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/cachelab.c
// Address range: 0x157a - 0x166d
// Line range:    30 - 41
void initMatrix(int32_t M, uint32_t N, int32_t (*A)[1], int32_t (*B2)[1]) {
    // 0x157a
    srand(time(NULL));
    if (N <= 0) {
        // 0x1661
        return;
    }
    int64_t v1 = 0;
    int64_t v2; // 0x157a
    int64_t v3; // 0x15fa
    int32_t v4; // 0x1638
    if (M > 0) {
        // 0x15ed
        v3 = v1 * (int64_t)M;
        v2 = 0;
        *(int32_t *)(4 * (v2 + v3) + (int64_t)A) = rand();
        v4 = rand();
        *(int32_t *)(4 * (v2 * (int64_t)N + v1) + (int64_t)B2) = v4;
        v2++;
        while (v2 != (int64_t)M) {
            // 0x15ed
            *(int32_t *)(4 * (v2 + v3) + (int64_t)A) = rand();
            v4 = rand();
            *(int32_t *)(4 * (v2 * (int64_t)N + v1) + (int64_t)B2) = v4;
            v2++;
        }
    }
    int64_t v5 = v1 + 1;
    while (v5 != (int64_t)N) {
        // 0x164d
        v1 = v5;
        if (M > 0) {
            // 0x15ed
            v3 = v1 * (int64_t)M;
            v2 = 0;
            *(int32_t *)(4 * (v2 + v3) + (int64_t)A) = rand();
            v4 = rand();
            *(int32_t *)(4 * (v2 * (int64_t)N + v1) + (int64_t)B2) = v4;
            v2++;
            while (v2 != (int64_t)M) {
                // 0x15ed
                *(int32_t *)(4 * (v2 + v3) + (int64_t)A) = rand();
                v4 = rand();
                *(int32_t *)(4 * (v2 * (int64_t)N + v1) + (int64_t)B2) = v4;
                v2++;
            }
        }
        // 0x1655
        v5 = v1 + 1;
    }
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/cachelab.c
// Address range: 0x166d - 0x170e
// Line range:    43 - 52
void randMatrix(int32_t M, uint32_t N, int32_t (*A)[1]) {
    // 0x166d
    srand(time(NULL));
    if (N <= 0) {
        // 0x1704
        return;
    }
    int64_t v1 = 0;
    int64_t v2; // 0x166d
    int64_t v3; // 0x16cc
    if (M > 0) {
        // 0x16bf
        v3 = v1 * (int64_t)M;
        v2 = 0;
        *(int32_t *)(4 * (v2 + v3) + (int64_t)A) = rand();
        v2++;
        while (v2 != (int64_t)M) {
            // 0x16bf
            *(int32_t *)(4 * (v2 + v3) + (int64_t)A) = rand();
            v2++;
        }
    }
    int64_t v4 = v1 + 1;
    while (v4 != (int64_t)N) {
        // 0x16f0
        v1 = v4;
        if (M > 0) {
            // 0x16bf
            v3 = v1 * (int64_t)M;
            v2 = 0;
            *(int32_t *)(4 * (v2 + v3) + (int64_t)A) = rand();
            v2++;
            while (v2 != (int64_t)M) {
                // 0x16bf
                *(int32_t *)(4 * (v2 + v3) + (int64_t)A) = rand();
                v2++;
            }
        }
        // 0x16f8
        v4 = v1 + 1;
    }
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/cachelab.c
// Address range: 0x170e - 0x17d2
// Line range:    57 - 66
void correctTrans(int32_t M, uint32_t N, int32_t (*A)[1], int32_t (*B2)[1]) {
    if (N <= 0) {
        // 0x17cf
        return;
    }
    int64_t v1 = 0;
    int64_t v2; // 0x170e
    int64_t v3; // 0x1773
    int32_t v4; // 0x1788
    if (M > 0) {
        // 0x1766
        v3 = v1 * (int64_t)M;
        v2 = 0;
        v4 = *(int32_t *)(4 * (v2 + v3) + (int64_t)A);
        *(int32_t *)(4 * (v2 * (int64_t)N + v1) + (int64_t)B2) = v4;
        v2++;
        while (v2 != (int64_t)M) {
            // 0x1766
            v4 = *(int32_t *)(4 * (v2 + v3) + (int64_t)A);
            *(int32_t *)(4 * (v2 * (int64_t)N + v1) + (int64_t)B2) = v4;
            v2++;
        }
    }
    int64_t v5 = v1 + 1;
    while (v5 != (int64_t)N) {
        // 0x17bb
        v1 = v5;
        if (M > 0) {
            // 0x1766
            v3 = v1 * (int64_t)M;
            v2 = 0;
            v4 = *(int32_t *)(4 * (v2 + v3) + (int64_t)A);
            *(int32_t *)(4 * (v2 * (int64_t)N + v1) + (int64_t)B2) = v4;
            v2++;
            while (v2 != (int64_t)M) {
                // 0x1766
                v4 = *(int32_t *)(4 * (v2 + v3) + (int64_t)A);
                *(int32_t *)(4 * (v2 * (int64_t)N + v1) + (int64_t)B2) = v4;
                v2++;
            }
        }
        // 0x17c3
        v5 = v1 + 1;
    }
}

// From module:   /home/tao/Autolab/courses/ics2020/cachelab/src/cachelab.c
// Address range: 0x17d2 - 0x189d
// Line range:    74 - 84
void registerTransFunction(void (*trans)(int32_t, int32_t, int32_t (*)[1], int32_t (*)[1]), char * desc) {
    int64_t v1 = 32 * (int64_t)func_counter;
    *(int64_t *)(v1 + (int64_t)&func_list) = (int64_t)trans;
    *(int64_t *)(v1 + (int64_t)&g6) = (int64_t)desc;
    *(char *)(v1 + (int64_t)&g7) = 0;
    *(int32_t *)(32 * (int64_t)func_counter + (int64_t)&g8) = 0;
    *(int32_t *)(32 * (int64_t)func_counter + (int64_t)&g9) = 0;
    *(int32_t *)(32 * (int64_t)func_counter + (int64_t)&g10) = 0;
    func_counter++;
}

// // Address range: 0x18a0 - 0x1905
// int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3) {
//     int64_t result = _init(); // 0x18cc
//     if ((int64_t)&g3 - (int64_t)&g2 >> 3 == 0) {
//         // 0x18f6
//         return result;
//     }
//     int64_t v1 = 0; // 0x18d4
//     while (v1 + 1 != (int64_t)&g3 - (int64_t)&g2 >> 3) {
//         // 0x18e0
//         v1++;
//     }
//     // 0x18f6
//     return result;
// }

// // Address range: 0x1910 - 0x1912
// int64_t __libc_csu_fini(void) {
//     // 0x1910
//     int64_t result; // 0x1910
//     return result;
// }

// // Address range: 0x1914 - 0x191d
// int64_t _fini(void) {
//     // 0x1914
//     int64_t result; // 0x1914
//     return result;
// }

// --------------- Dynamically Linked Functions ---------------

// void __assert_fail(const char * assertion, const char * file, unsigned int line, const char * function);
// void __cxa_finalize(void * d);
// int * __errno_location(void);
// void __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// void __stack_chk_fail(void);
// int atoi(const char * nptr);
// void exit(int status);
// int fclose(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// void free(void * ptr);
// int getopt(int argc, char * const * argv, const char * shortopts);
// void * malloc(size_t size);
// int printf(const char * restrict format, ...);
// int putchar(int c);
// int puts(const char * s);
// int rand(void);
// void srand(unsigned int seed);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// char * strerror(int errnum);
// time_t time(time_t * timer);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.5.0)
// Detected language: C
// Detected functions: 41