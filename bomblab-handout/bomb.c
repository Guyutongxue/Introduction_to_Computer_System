//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t blank_line(int64_t a1);
int64_t deregister_tm_clones(void);
int64_t driver_post(char * a1, char * a2, char * a3, int64_t * a4, int64_t a5, int64_t * a6);
int64_t explode_bomb(int64_t a1);
int64_t frame_dummy(void);
int64_t func4(int64_t a1, int64_t a2);
int32_t function_1000(int32_t seconds);
int16_t ** function_1010(void);
int32_t function_1020(char * s, int32_t flag, int32_t slen, char * format, ...);
int32_t function_1030(int32_t domain, int32_t type, int32_t protocol);
void function_1040(int64_t * d);
char * function_e80(char * name);
int32_t function_e90(char * s1, char * s2);
int32_t * function_ea0(void);
char * function_eb0(char * dest, char * src);
int32_t function_ec0(char * s);
int32_t function_ed0(int32_t fd, int64_t * buf, int32_t n);
void function_ee0(void);
int32_t function_ef0(int32_t seconds);
int32_t function_f00(int32_t fd);
int32_t function_f10(int32_t fd, int64_t * buf, int32_t nbytes);
char * function_f20(char * s, int32_t n, struct _IO_FILE * stream);
void (*function_f30(int32_t sig, void (*handler)(int32_t)))(int32_t);
struct hostent * function_f40(char * name);
int64_t * function_f50(int64_t * dest, int64_t * src, int32_t len, int32_t dstlen);
int32_t function_f60(char * nptr, char ** endptr, int32_t base);
int64_t * function_f70(int64_t * dest, int64_t * src, int32_t n);
int32_t function_f80(struct _IO_FILE * stream);
int32_t function_f90(char * s, char * format, ...);
int32_t function_fa0(int32_t flag, char * format, ...);
struct _IO_FILE * function_fb0(char * filename, char * modes);
int32_t function_fc0(char * name, int32_t len);
void function_fd0(int32_t status);
int32_t function_fe0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_ff0(struct _IO_FILE * stream, int32_t flag, char * format, ...);
int64_t get_sum(int64_t a1);
int64_t init_driver(int64_t * a1);
int64_t init_timeout(int64_t a1);
int64_t initialize_bomb(int32_t * a1);
int64_t initialize_bomb_solve(void);
int64_t invalid_phase(int64_t a1);
int64_t phase_1(int64_t a1);
int64_t phase_2(int64_t a1);
int64_t phase_3(int64_t a1, int64_t a2);
int64_t phase_4(int64_t str);
int64_t phase_5(int64_t a1);
int64_t phase_6(int64_t a1);
int64_t phase_defused(void);
int64_t read_line(void);
int64_t read_six_numbers(int64_t str, int64_t * a2);
int64_t register_tm_clones(void);
int64_t rio_read(int64_t a1, int64_t * a2, uint64_t a3);
int64_t rio_readinitb(int64_t * a1, int64_t a2);
int64_t rio_readlineb(int64_t * a1, int64_t * a2, uint64_t a3);
int64_t rio_writen(int64_t fd, int64_t * a2, int64_t a3);
int64_t secret_phase(void);
int64_t send_msg(int64_t a1, int32_t * a2);
int64_t sig_handler(void);
int64_t sigalrm_handler(void);
int64_t skip(void);
int64_t string_length(int64_t a1);
int64_t strings_not_equal(int64_t a1, char * a2);
int64_t submitr(char * name, int64_t * a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7);
int64_t urlencode(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x1150; // 0x203cd0
int64_t g2 = 0x1110; // 0x203cd8
int32_t g3 = 275; // 0x2050a0
int64_t g4 = 0x100000322; // 0x205110
char * g5[9] = {
    "ics_2019",
    "localhost",
    "spring",
    "summer",
    "autumn",
    "winter",
    "autolab.pku.edu.cn",
    "netserver",
    "icsdancer"
}; // 0x205160
struct _IO_FILE * g6 = NULL; // 0x2053e0
int64_t g7 = 0; // 0x2053f0
struct _IO_FILE * g8 = NULL; // 0x205400
char g9 = 0; // 0x205408
int32_t g10 = 0; // 0x20540b
int128_t g11; // 0x20540c
int32_t g12 = 0; // 0x20540d
char * g13; // 0x205420
char * g14; // 0x205510
char * g15 = "Don't try to make the bomb run on your local machine!(*/w\xef\xbc\xbc*)"; // 0x2c08
int32_t * g16 = (int32_t *)-0x195500001980; // 0x2d80
int32_t * g17 = (int32_t *)0x600000002; // 0x2da0
char * g18 = "Don't try to make the bomb not explode on your local machine!(*/w\xef\xbc\xbc*)"; // 0x2e90
int64_t g19 = 0x120000007a; // 0x400
int64_t g20 = 0x203ef8; // 0xbb8
int64_t infile = 0; // 0x205410
int32_t g21;

// ------------------------ Functions -------------------------

// Address range: 0xe58 - 0xe6f
int64_t _init(void) {
    int64_t result = 0; // 0xe66
    if (*(int64_t *)0x203fe8 != 0) {
        // 0xe68
        __gmon_start__();
        result = &g21;
    }
    // 0xe6a
    return result;
}

// Address range: 0xe80 - 0xe86
char * function_e80(char * name) {
    // 0xe80
    return getenv(name);
}

// Address range: 0xe90 - 0xe96
int32_t function_e90(char * s1, char * s2) {
    // 0xe90
    return strcasecmp(s1, s2);
}

// Address range: 0xea0 - 0xea6
int32_t * function_ea0(void) {
    // 0xea0
    return __errno_location();
}

// Address range: 0xeb0 - 0xeb6
char * function_eb0(char * dest, char * src) {
    // 0xeb0
    return strcpy(dest, src);
}

// Address range: 0xec0 - 0xec6
int32_t function_ec0(char * s) {
    // 0xec0
    return puts(s);
}

// Address range: 0xed0 - 0xed6
int32_t function_ed0(int32_t fd, int64_t * buf, int32_t n) {
    // 0xed0
    return write(fd, buf, n);
}

// Address range: 0xee0 - 0xee6
void function_ee0(void) {
    // 0xee0
    __stack_chk_fail();
}

// Address range: 0xef0 - 0xef6
int32_t function_ef0(int32_t seconds) {
    // 0xef0
    return alarm(seconds);
}

// Address range: 0xf00 - 0xf06
int32_t function_f00(int32_t fd) {
    // 0xf00
    return close(fd);
}

// Address range: 0xf10 - 0xf16
int32_t function_f10(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0xf10
    return read(fd, buf, nbytes);
}

// Address range: 0xf20 - 0xf26
char * function_f20(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0xf20
    return fgets(s, n, stream);
}

// Address range: 0xf30 - 0xf36
void (*function_f30(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0xf30
    return signal(sig, handler);
}

// Address range: 0xf40 - 0xf46
struct hostent * function_f40(char * name) {
    // 0xf40
    return gethostbyname(name);
}

// Address range: 0xf50 - 0xf56
int64_t * function_f50(int64_t * dest, int64_t * src, int32_t len, int32_t dstlen) {
    // 0xf50
    return __memmove_chk(dest, src, len, dstlen);
}

// Address range: 0xf60 - 0xf66
int32_t function_f60(char * nptr, char ** endptr, int32_t base) {
    // 0xf60
    return strtol(nptr, endptr, base);
}

// Address range: 0xf70 - 0xf76
int64_t * function_f70(int64_t * dest, int64_t * src, int32_t n) {
    // 0xf70
    return memcpy(dest, src, n);
}

// Address range: 0xf80 - 0xf86
int32_t function_f80(struct _IO_FILE * stream) {
    // 0xf80
    return fflush(stream);
}

// Address range: 0xf90 - 0xf96
int32_t function_f90(char * s, char * format, ...) {
    // 0xf90
    return sscanf(s, format);
}

// Address range: 0xfa0 - 0xfa6
int32_t function_fa0(int32_t flag, char * format, ...) {
    // 0xfa0
    return __printf_chk(flag, format);
}

// Address range: 0xfb0 - 0xfb6
struct _IO_FILE * function_fb0(char * filename, char * modes) {
    // 0xfb0
    return fopen(filename, modes);
}

// Address range: 0xfc0 - 0xfc6
int32_t function_fc0(char * name, int32_t len) {
    // 0xfc0
    return gethostname(name, len);
}

// Address range: 0xfd0 - 0xfd6
void function_fd0(int32_t status) {
    // 0xfd0
    exit(status);
}

// Address range: 0xfe0 - 0xfe6
int32_t function_fe0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0xfe0
    return connect(fd, addr, len);
}

// Address range: 0xff0 - 0xff6
int32_t function_ff0(struct _IO_FILE * stream, int32_t flag, char * format, ...) {
    // 0xff0
    return __fprintf_chk(stream, flag, format);
}

// Address range: 0x1000 - 0x1006
int32_t function_1000(int32_t seconds) {
    // 0x1000
    return sleep(seconds);
}

// Address range: 0x1010 - 0x1016
int16_t ** function_1010(void) {
    // 0x1010
    return __ctype_b_loc();
}

// Address range: 0x1020 - 0x1026
int32_t function_1020(char * s, int32_t flag, int32_t slen, char * format, ...) {
    // 0x1020
    return __sprintf_chk(s, flag, slen, format);
}

// Address range: 0x1030 - 0x1036
int32_t function_1030(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1030
    return socket(domain, type, protocol);
}

// Address range: 0x1040 - 0x1046
void function_1040(int64_t * d) {
    // 0x1040
    __cxa_finalize(d);
}

// Address range: 0x1050 - 0x107b
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1050
    int64_t v1; // 0x1050
    __libc_start_main(0x115a, (int32_t)a4, (char **)&v1, (void (*)())0x2b00, (void (*)())0x2b70, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1080 - 0x10b2
int64_t deregister_tm_clones(void) {
    // 0x1080
    return (int64_t)&g6;
}

// Address range: 0x10c0 - 0x1102
int64_t register_tm_clones(void) {
    // 0x10c0
    return 0;
}

// Address range: 0x1110 - 0x114a
int64_t __do_global_dtors_aux(void) {
    // 0x1110
    if (g9 != 0) {
        // 0x1148
        int64_t result; // 0x1110
        return result;
    }
    // 0x1119
    if (*(int64_t *)0x203ff8 != 0) {
        // 0x1127
        __cxa_finalize((int64_t *)*(int64_t *)0x204008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1133
    g9 = 1;
    return result2;
}

// Address range: 0x1150 - 0x115a
int64_t frame_dummy(void) {
    // 0x1150
    return register_tm_clones();
}

// From module:   /home/tao/Autolab/courses/ics2020/bomblab/src/bomb.c
// Address range: 0x115a - 0x130d
// Line range:    36 - 120
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x115f
    if (argc == 1) {
        // 0x11ee
        infile = g7;
    } else {
        if (argc != 2) {
            // 0x1220
            __printf_chk(1, "Usage: %s [<input_file>]\n", argv);
            exit(8);
            // UNREACHABLE
        }
        int64_t * file_path = (int64_t *)((int64_t)argv + 8); // 0x1180
        struct _IO_FILE * file = fopen((char *)*file_path, "r"); // 0x118b
        infile = (int64_t)file;
        if (file == NULL) {
            // 0x11fe
            __printf_chk(1, "%s: Error: Couldn't open %s\n", "r", (char *)*file_path);
            exit(8);
            // UNREACHABLE
        }
    }
    int32_t v2 = 0; // bp-20, 0x119c
    initialize_bomb(&v2);
    if (v2 == 1) {
        // 0x1243
        puts("Welcome to my fiendish little bomb. You have 6 phases with");
        puts("which to blow yourself up. Have a nice day!");
        phase_1(read_line());
        phase_defused();
        puts("Phase 1 defused. How about the next one?");
        phase_2(read_line());
        phase_defused();
        puts("That's number 2.  Keep going!");
        read_line();
        phase_3((int64_t)&g21, (int64_t)&g21);
        phase_defused();
        puts("Halfway there!");
        phase_4(read_line());
        phase_defused();
        puts("So you got that one.  Try this one.");
        phase_5(read_line());
        phase_defused();
        puts("Good work!  On to the next...");
        phase_6(read_line());
        phase_defused();
    } else {
        // 0x11b9
        __printf_chk(1, (char *)&g15);
    }
    // 0x11cf
    if (v1 == __readfsqword(40)) {
        // 0x11e8
        return 0;
    }
    // 0x1308
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x130d - 0x132d
int64_t phase_1(int64_t a1) {
    int64_t result = strings_not_equal(a1, "For NASA, space is still a high priority."); // 0x1318
    if ((int32_t)result == 0) {
        // 0x1321
        return result;
    }
    // 0x1326
    explode_bomb(a1);
    // UNREACHABLE
}

// Address range: 0x132d - 0x13a6
int64_t phase_2(int64_t a1) {
    // 0x132d
    int32_t v1; // bp-40, 0x132d
    int64_t v2 = &v1; // 0x132e
    int64_t v3 = __readfsqword(40); // 0x1332
    read_six_numbers(a1, (int64_t *)&v1);
    int64_t v4 = 2; // 0x134e
    int32_t v5; // 0x132d
    if (v5 == 1 != (v1 == 0)) {
        // 0x1357
        explode_bomb(a1);
        // UNREACHABLE
    }
    int64_t v6 = 0x100000000 * v4;
    int32_t v7 = *(int32_t *)((v6 - 0x200000000) / 0x40000000 + v2); // 0x137c
    int32_t v8 = *(int32_t *)(v6 / 0x40000000 + v2); // 0x137f
    while (v8 == v7 + *(int32_t *)((v6 - 0x100000000) / 0x40000000 + v2)) {
        int64_t v9 = v4 + 1; // 0x1363
        v4 = v9 & 0xffffffff;
        if ((int32_t)v9 > 5) {
            int64_t result = __readfsqword(40) ^ v3; // 0x1390
            if (result == 0) {
                // 0x139b
                return result;
            }
            // 0x13a1
            __stack_chk_fail();
            return &g21;
        }
        v6 = 0x100000000 * v4;
        v7 = *(int32_t *)((v6 - 0x200000000) / 0x40000000 + v2);
        v8 = *(int32_t *)(v6 / 0x40000000 + v2);
    }
    // 0x1384
    explode_bomb(a1);
    // UNREACHABLE
}

// Address range: 0x13a6 - 0x148b
int64_t phase_3(int64_t a1, int64_t a2) {
    // 0x13a6
    __readfsqword(40);
    int64_t v1; // bp-20, 0x13a6
    int64_t v2; // bp-24, 0x13a6
    int64_t v3; // bp-28, 0x13a6
    int64_t str; // 0x13a6
    if (sscanf((char *)str, "%d %d %d", &v3, &v2, &v1) < 3) {
        // 0x13f9
        explode_bomb(str);
        // UNREACHABLE
    }
    // 0x13da
    if ((int32_t)v3 < 8) {
        int32_t v4 = *(int32_t *)((4 * v3 & 0x3fffffffc) + (int64_t)&g16); // 0x13f0
        return (int64_t)v4 + (int64_t)&g16;
    }
    // 0x1477
    explode_bomb(str);
    // UNREACHABLE
}

// Address range: 0x148b - 0x14c3
int64_t func4(int64_t a1, int64_t a2) {
    int32_t v1 = a1; // 0x148b
    if (v1 < 1) {
        // 0x14bd
        return 0;
    }
    if (v1 == 1) {
        // 0x1494
        return a2 & 0xffffffff;
    }
    int64_t v2 = func4(a1 + 0xffffffff & 0xffffffff, a2); // 0x14a2
    return v2 + a2 + func4(a1 + 0xfffffffe & 0xffffffff, a2 & 0xffffffff) & 0xffffffff;
}

// Address range: 0x14c3 - 0x1534
int64_t phase_4(int64_t str) {
    int64_t v1 = __readfsqword(40); // 0x14c7
    int64_t v2; // bp-20, 0x14c3
    int64_t v3; // bp-24, 0x14c3
    if (sscanf((char *)str, "%d %d", &v2, &v3) != 2 || (int32_t)v3 >= 5) {
        // 0x14fd
        explode_bomb(str);
        // UNREACHABLE
    }
    // 0x1502
    if ((int32_t)v2 != (int32_t)func4(5, v3 & 0xffffffff)) {
        // 0x1515
        explode_bomb(5);
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x151f
    if (result == 0) {
        // 0x152a
        return result;
    }
    // 0x152f
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x1534 - 0x1581
int64_t phase_5(int64_t a1) {
    int64_t v1 = 0; // 0x1540
    int32_t v2 = 1; // 0x1540
    if ((int32_t)string_length(a1) != 4) {
        // 0x154e
        explode_bomb(a1);
        // UNREACHABLE
    }
    char v3 = *(char *)(0x100000000 * v1 / 0x100000000 + a1); // 0x1558
    int32_t v4 = *(int32_t *)((int64_t)(4 * v3 & 28) + (int64_t)&g17); // 0x1566
    v2 *= v4;
    int64_t v5 = v1 + 1; // 0x156a
    v1 = v5 & 0xffffffff;
    while ((int32_t)v5 < 4) {
        // 0x1555
        v3 = *(char *)(0x100000000 * v1 / 0x100000000 + a1);
        v4 = *(int32_t *)((int64_t)(4 * v3 & 28) + (int64_t)&g17);
        v2 *= v4;
        v5 = v1 + 1;
        v1 = v5 & 0xffffffff;
    }
    if (v2 == 320) {
        // 0x157f
        return 4;
    }
    // 0x157a
    explode_bomb(a1);
    // UNREACHABLE
}

// Address range: 0x1581 - 0x168c
int64_t phase_6(int64_t a1) {
    // 0x1581
    int64_t v1; // bp-120, 0x1581
    int64_t v2 = &v1; // 0x1585
    int64_t v3 = __readfsqword(40); // 0x1589
    read_six_numbers(a1, &v1);
    int64_t v4 = 0; // 0x15e2
    int64_t v5 = a1;
    int32_t v6 = *(int32_t *)(0x100000000 * v4 / 0x40000000 + v2); // 0x15d7
    int64_t v7; // 0x1581
    int64_t v8; // 0x1581
    while (v6 < 7) {
        int64_t v9 = v4 + 1; // 0x15e2
        v4 = v9 & 0xffffffff;
        int64_t v10 = v9; // 0x15b5
        if ((int32_t)v9 > 5) {
            // 0x1609
            v8 = v2 + 32;
            v7 = 0;
            goto lab_0x15f9;
        }
        uint32_t v11 = *(int32_t *)(0x100000000 * v10 / 0x40000000 + v2); // 0x15bd
        if (v6 == v11) {
            // 0x15c5
            explode_bomb((int64_t)v11);
            // UNREACHABLE
        }
        // 0x15b2
        v10 = (v10 & 0xffffffff) + 1;
        while ((int32_t)v10 <= 5) {
            // 0x15b7
            v11 = *(int32_t *)(0x100000000 * v10 / 0x40000000 + v2);
            if (v6 == v11) {
                // 0x15c5
                explode_bomb((int64_t)v11);
                // UNREACHABLE
            }
            // 0x15b2
            v10 = (v10 & 0xffffffff) + 1;
        }
        // 0x15cf
        v5 = v11;
        v6 = *(int32_t *)(0x100000000 * v4 / 0x40000000 + v2);
    }
    // 0x15a8
    explode_bomb(v5);
    // UNREACHABLE
  lab_0x15f9:;
    int64_t v12 = 0x100000000 * v7;
    int32_t v13 = *(int32_t *)(v12 / 0x40000000 + v2); // 0x15fc
    int64_t v14 = &g4; // 0x15ff
    int64_t v15; // 0x1581
    int64_t v16; // 0x1581
    if (v13 > 1) {
        // 0x15f2
        v16 = &g4;
        v15 = 1;
        goto lab_0x15f2_2;
    } else {
        goto lab_0x1601;
    }
  lab_0x1601:
    // 0x1601
    *(int64_t *)(v12 / 0x20000000 + v8) = v14;
    int64_t v17 = v7 + 1; // 0x1606
    v7 = v17 & 0xffffffff;
    int64_t v18; // 0x1581
    int64_t v19; // 0x1581
    int32_t * v20; // 0x1581
    int64_t v21; // 0x161c
    if ((int32_t)v17 > 5) {
        // 0x161c
        v21 = (int64_t)v20;
        v19 = v21;
        v18 = 1;
        goto lab_0x162b;
    } else {
        goto lab_0x15f9;
    }
  lab_0x15f2_2:;
    int64_t v22 = *(int64_t *)(v16 + 8); // 0x15f2
    int64_t v23 = v15 + 1 & 0xffffffff; // 0x15f6
    v16 = v22;
    v15 = v23;
    v14 = v22;
    if (v23 < (int64_t)v13) {
        goto lab_0x15f2_2;
    } else {
        goto lab_0x1601;
    }
  lab_0x162b:;
    int64_t v24 = *(int64_t *)(0x100000000 * v18 / 0x20000000 + v8); // 0x162e
    *(int64_t *)(v19 + 8) = v24;
    int64_t v25 = v18 + 1; // 0x1637
    v19 = v24;
    v18 = v25 & 0xffffffff;
    int32_t v26; // 0x1581
    int64_t v27; // 0x1581
    int64_t v28; // 0x1581
    if ((int32_t)v25 < 6) {
        goto lab_0x162b;
    } else {
        // 0x1642
        *(int64_t *)(v24 + 8) = 0;
        v26 = *v20;
        v28 = 0;
        v27 = v21;
        goto lab_0x165d;
    }
  lab_0x165d:;
    int64_t v29 = *(int64_t *)(v27 + 8); // 0x165d
    uint32_t v30 = *(int32_t *)v29; // 0x1661
    if ((int64_t)v26 > (int64_t)v30) {
        // 0x1667
        explode_bomb(v5);
        // UNREACHABLE
    }
    int64_t v31 = v28 + 1; // 0x1655
    v26 = v30;
    v28 = v31 & 0xffffffff;
    v27 = v29;
    if ((int32_t)v31 > 4) {
        int64_t result = __readfsqword(40) ^ v3; // 0x1673
        if (result == 0) {
            // 0x167e
            return result;
        }
        // 0x1687
        __stack_chk_fail();
        return &g21;
    }
    goto lab_0x165d;
}

// Address range: 0x168c - 0x16d7
int64_t get_sum(int64_t a1) {
    uint32_t v1 = *(int32_t *)(a1 + 16); // 0x168c
    int64_t result = v1; // 0x168c
    switch (v1) {
        case 0: {
            // 0x16ad
            return (int64_t)(*(int32_t *)(a1 + 8) + (int32_t)a1);
        }
        case 1: {
            // 0x16b3
            result = (int64_t)(*(int32_t *)(a1 + 8) + (int32_t)get_sum(a1));
            // break -> 0x16a6
            break;
        }
        case 2: {
            int64_t v2 = get_sum(a1); // 0x16c3
            result = get_sum(*(int64_t *)(a1 + 8)) + v2 & 0xffffffff;
            // break -> 0x16a6
            break;
        }
    }
    // 0x16a6
    return result;
}

// Address range: 0x16d7 - 0x171a
int64_t secret_phase(void) {
    int32_t str_as_l = strtol((char *)read_line(), NULL, 10); // 0x16ea
    if (str_as_l == (int32_t)get_sum(0x2050b0)) {
        // 0x1707
        puts("Wow! You've defused the secret stage!");
        return phase_defused();
    }
    // 0x1702
    explode_bomb(0x2050b0);
    // UNREACHABLE
}

// Address range: 0x171a - 0x1776
int64_t sig_handler(void) {
    // 0x171a
    puts("So you think you can stop the bomb with ctrl-c, do you?");
    sleep(3);
    __printf_chk(1, "Well...");
    fflush(g6);
    sleep(1);
    puts("OK. :-)");
    exit(16);
    return &g21;
}

// Address range: 0x1776 - 0x179d
int64_t invalid_phase(int64_t a1) {
    // 0x1776
    __printf_chk(1, "Invalid phase%s\n", (char *)a1);
    exit(8);
    return &g21;
}

// Address range: 0x179d - 0x17b2
int64_t string_length(int64_t a1) {
    int64_t result = 0; // 0x17ae
    if (*(char *)a1 == 0) {
        // 0x17b0
        return 0;
    }
    int64_t v1 = a1; // 0x17ae
    v1++;
    result = result + 1 & 0xffffffff;
    while (*(char *)v1 != 0) {
        // 0x17a4
        v1++;
        result = result + 1 & 0xffffffff;
    }
    // 0x17b0
    return result;
}

// Address range: 0x17b2 - 0x17ff
int64_t strings_not_equal(int64_t a1, char * a2) {
    int64_t v1 = (int64_t)a2;
    int64_t v2 = string_length(a1); // 0x17bc
    if ((int32_t)v2 != (int32_t)string_length(v1)) {
        // 0x17d6
        return 1;
    }
    char v3 = *(char *)a1; // 0x17db
    char v4 = v3; // 0x17e0
    int64_t v5 = v1; // 0x17e0
    if (v3 == 0) {
        // 0x17d6
        return 0;
    }
    int64_t v6 = a1; // 0x17e0
    int64_t result = 1; // 0x17e5
    while (*(char *)v5 == v4) {
        // 0x17e7
        v6++;
        v4 = *(char *)v6;
        result = 0;
        v5++;
        if (v4 == 0) {
            // break -> 0x17d6
            break;
        }
        result = 1;
    }
    // 0x17d6
    return result;
}

// Address range: 0x17ff - 0x18fe
int64_t initialize_bomb(int32_t * a1) {
    int64_t v1 = __readfsqword(40); // 0x180d
    signal(SIGINT, 0x171a);
    int64_t name; // bp-8296, 0x17ff
    int32_t v2 = gethostname((char *)&name, 64); // 0x1839
    if (v2 != 0) {
        // 0x186a
        puts("Initialization error: Running on an illegal host [1]");
        exit(8);
        // UNREACHABLE
    }
    int64_t v3 = v2; // 0x1839
    int64_t v4 = *(int64_t *)(8 * v3 + (int64_t)&g5); // 0x1850
    int64_t str = v4; // 0x1857
    int64_t v5 = v3; // 0x1857
    if (v4 == 0) {
      lab_0x18be:
        // 0x18be
        puts("Initialization error: Running on an illegal host [2]");
        exit(8);
        // UNREACHABLE
    }
    while (strcasecmp((char *)str, (char *)&name) != 0) {
        // 0x1846
        v5 = (v5 & 0xffffffff) + 1;
        str = *(int64_t *)(0x100000000 * v5 / 0x20000000 + (int64_t)&g5);
        if (str == 0) {
            if (v2 == 0) {
                goto lab_0x18be;
            } else {
                goto lab_0x1889;
            }
        }
    }
    goto lab_0x1889;
  lab_0x1889:;
    // 0x1889
    int64_t v6; // bp-8232, 0x17ff
    if ((int32_t)init_driver(&v6) < 0) {
        // 0x18d4
        __printf_chk(1, "Initialization error:\n%s\n", &v6);
        exit(8);
        // UNREACHABLE
    }
    // 0x1897
    *a1 = 1;
    int64_t result = __readfsqword(40) ^ v1; // 0x18a7
    if (result == 0) {
        // 0x18b2
        return result;
    }
    // 0x18f9
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x18fe - 0x1900
int64_t initialize_bomb_solve(void) {
    // 0x18fe
    int64_t result; // 0x18fe
    return result;
}

// Address range: 0x1900 - 0x193b
int64_t blank_line(int64_t a1) {
    int64_t v1 = a1; // 0x1906
    unsigned char v2 = *(char *)v1; // 0x1909
    int64_t result = 1; // 0x190f
    while (v2 != 0) {
        int16_t * v3 = *__ctype_b_loc(); // 0x1916
        char v4 = *(char *)((0x100000000000000 * (int64_t)v2 / 0x80000000000000 | 1) + (int64_t)v3); // 0x1921
        v1++;
        result = 0;
        if ((v4 & 32) == 0) {
            // break -> 0x1934
            break;
        }
        v2 = *(char *)v1;
        result = 1;
    }
    // 0x1934
    return result;
}

// Address range: 0x193b - 0x1982
int64_t skip(void) {
    int32_t v1 = *(int32_t *)&g11; // 0x193c
    char * str = fgets((char *)(80 * (int64_t)v1 + (int64_t)&g13), 80, (struct _IO_FILE *)infile); // 0x1964
    while (str != NULL) {
        // 0x1971
        if ((int32_t)blank_line((int64_t)str) == 0) {
            // break -> 0x197d
            break;
        }
        v1 = *(int32_t *)&g11;
        str = fgets((char *)(80 * (int64_t)v1 + (int64_t)&g13), 80, (struct _IO_FILE *)infile);
    }
    // 0x197d
    return (int64_t)str;
}

// Address range: 0x1982 - 0x1acf
int64_t send_msg(int64_t a1, int32_t * a2) {
    int64_t v1 = __readfsqword(40); // 0x1991
    int64_t v2 = (int64_t)*(int32_t *)&g11; // 0x19a4
    int64_t v3 = -1; // 0x19d3
    int64_t v4 = (int64_t)&g13 + 16 * ((int64_t)(int32_t)&g10 + 4 * (int64_t)(int32_t)&g10); // 0x19d3
    int64_t v5 = 0; // 0x19d3
    while (v3 != 0) {
        int64_t v6 = v4;
        v3--;
        bool v7; // 0x1982
        v4 = v6 + (v7 ? -1 : 1);
        v5 = v3;
        if (*(char *)v6 == 0) {
            // break ->
            break;
        }
        v5 = 0;
    }
    if (-v5 >= 0x1f9f) {
        // 0x1a87
        __printf_chk(1, "ERROR: Input string is too large.");
        exit(8);
        // UNREACHABLE
    }
    char * v8 = (int32_t)a1 == 0 ? "exploded" : "defused"; // 0x1a04
    int64_t v9; // bp-16424, 0x1982
    __sprintf_chk((char *)&v9, 1, 0x2000, "%d:%s:%s:%d:%s", (int64_t)g3, "1673026", v8, v2, (char *)((int64_t)&g13 + 16 * ((int64_t)(int32_t)&g10 + 4 * (int64_t)(int32_t)&g10)));
    int64_t str; // bp-8232, 0x1982
    int64_t v10 = driver_post("1900012983@pku.edu.cn", "ics2020", "bomblab", &v9, 0, &str); // 0x1a5b
    *a2 = 1;
    if ((int32_t)v10 < 0) {
        // 0x1ab3
        puts((char *)&str);
        exit(0);
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x1a72
    if (result == 0) {
        // 0x1a7d
        return result;
    }
    // 0x1aca
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x1acf - 0x1b4f
int64_t explode_bomb(int64_t a1) {
    // 0x1acf
    __readfsqword(40);
    puts("\nBOOM!!!");
    puts("The bomb has blown up.");
    int32_t v1 = 0; // bp-20, 0x1afb
    send_msg(0, &v1);
    if (v1 == 1) {
        // 0x1b39
        puts("Your instructor has been notified.");
        exit(8);
        return &g21;
    }
    // 0x1b19
    __printf_chk(1, (char *)&g18);
    exit(8);
    // UNREACHABLE
}

// Address range: 0x1b4f - 0x1b90
int64_t read_six_numbers(int64_t str, int64_t * a2) {
    int64_t v1 = (int64_t)a2;
    int32_t items_assigned = sscanf((char *)str, "%d %d %d %d %d %d", a2, (int64_t *)(v1 + 4), (int64_t *)(v1 + 8), (int64_t *)(v1 + 12), (int64_t *)(v1 + 16), (int64_t *)(v1 + 20)); // 0x1b78
    if (items_assigned < 6) {
        // 0x1b8b
        return explode_bomb(str);
    }
    // 0x1b86
    return items_assigned;
}

// Address range: 0x1b90 - 0x1cd7
int64_t read_line(void) {
    // 0x1b90
    if (skip() == 0) {
        // 0x1c15
        if (infile == g7) {
            // 0x1c40
            puts("Error: Premature EOF on stdin");
            exit(8);
            // UNREACHABLE
        }
        // 0x1c25
        if (getenv("GRADE_BOMB") != NULL) {
            // 0x1c36
            exit(0);
            // UNREACHABLE
        }
        // 0x1c56
        infile = g7;
        if (skip() == 0) {
            // 0x1c77
            puts("Error: Premature EOF on stdin");
            exit(0);
            // UNREACHABLE
        }
    }
    uint32_t v1 = *(int32_t *)&g11; // 0x1ba3
    int64_t v2 = v1; // 0x1ba9
    int64_t result = 80 * v2 + (int64_t)&g13; // 0x1bbe
    int64_t v3 = -1; // 0x1bd0
    int64_t v4 = result; // 0x1bd0
    int64_t v5 = 0; // 0x1bd0
    while (v3 != 0) {
        int64_t v6 = v4;
        v3--;
        bool v7; // 0x1b90
        v4 = v6 + (v7 ? -1 : 1);
        v5 = v3;
        if (*(char *)v6 == 0) {
            // break ->
            break;
        }
        v5 = 0;
    }
    int64_t v8 = -2 - v5; // 0x1bd5
    if ((int32_t)v8 <= 78) {
        // 0x1be2
        *(char *)(16 * (0x100000000 * (int64_t)v1 / 0x40000000 + v2) + (int64_t)&g13 + (0x100000000 * v8 - 0x100000000) / 0x100000000) = 0;
        *(int32_t *)&g11 = (int32_t)&g12;
        return result;
    }
    // 0x1c8d
    puts("Error: Input line too long");
    *(int32_t *)&g11 = (int32_t)&g12;
    int64_t v9 = 80 * (int64_t)*(int32_t *)&g11; // 0x1caa
    *(int64_t *)(v9 + (int64_t)&g13) = 0x636e7572742a2a2a;
    *(int64_t *)(v9 + (int64_t)&g13 + 8) = 0x2a2a2a64657461;
    return explode_bomb(0x2a2a2a64657461);
}

// Address range: 0x1cd7 - 0x1da8
int64_t phase_defused(void) {
    int64_t v1 = __readfsqword(40); // 0x1cdb
    int32_t v2 = 0; // bp-108, 0x1ceb
    send_msg(1, &v2);
    if (*(int32_t *)&g11 == 6) {
        // 0x1d24
        int64_t v3; // bp-104, 0x1cd7
        int64_t v4; // bp-112, 0x1cd7
        int64_t v5; // bp-116, 0x1cd7
        int32_t items_assigned = sscanf((char *)&g14, "%d %d %s", &v5, &v4, &v3); // 0x1d46
        if (items_assigned == 3) {
            int64_t v6 = strings_not_equal((int64_t)&v3, "IsLifeAlwaysThisHard0rIsItJu3tWhenYouAreAK1d"); // 0x1d76
            if ((int32_t)v6 == 0) {
                // 0x1d7f
                puts("Curses, you've found the secret phase!");
                puts("But finding it and solving it are quite different...");
                secret_phase();
            }
        }
        // 0x1d50
        puts("Congratulations! You've defused the bomb!");
        puts("Your instructor has been notified and will verify your solution.");
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x1d10
    if (result == 0) {
        // 0x1d1f
        return result;
    }
    // 0x1da3
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x1da8 - 0x1dba
int64_t rio_readinitb(int64_t * a1, int64_t a2) {
    int64_t v1 = (int64_t)a1;
    *(int32_t *)a1 = (int32_t)a2;
    *(int32_t *)(v1 + 4) = 0;
    int64_t result = v1 + 16; // 0x1db1
    *(int64_t *)(v1 + 8) = result;
    return result;
}

// Address range: 0x1dba - 0x1dea
int64_t sigalrm_handler(void) {
    // 0x1dba
    __fprintf_chk(g8, 1, "Program timed out after %d seconds\n", 0);
    exit(1);
    return &g21;
}

// Address range: 0x1dea - 0x1e48
int64_t rio_writen(int64_t fd, int64_t * a2, int64_t a3) {
    // 0x1dea
    if (a3 == 0) {
        // 0x1e34
        return 0;
    }
    int64_t buf = (int64_t)a2; // 0x1dea
    int64_t nbyte = a3; // 0x1e02
    int32_t v1 = write((int32_t)fd, (int64_t *)buf, (int32_t)nbyte); // 0x1e16
    int64_t v2 = v1; // 0x1e1e
    int32_t v3; // 0x1e25
    if (v1 >= 0 != v1 != 0) {
        // 0x1e20
        v3 = *__errno_location();
        v2 = 0;
        if (v3 != 4) {
            // break -> 0x1e34
            break;
        }
    }
    // 0x1e02
    nbyte -= v2;
    buf += v2;
    int64_t result = a3; // 0x1e0b
    while (nbyte != 0) {
        // 0x1e0d
        v1 = write((int32_t)fd, (int64_t *)buf, (int32_t)nbyte);
        v2 = v1;
        if (v1 >= 0 != v1 != 0) {
            // 0x1e20
            v3 = *__errno_location();
            v2 = 0;
            result = -1;
            if (v3 != 4) {
                // break -> 0x1e34
                break;
            }
        }
        // 0x1e02
        nbyte -= v2;
        buf += v2;
        result = a3;
    }
    // 0x1e34
    return result;
}

// Address range: 0x1e48 - 0x1ed3
int64_t rio_read(int64_t a1, int64_t * a2, uint64_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x1e67
    int32_t v2 = *v1; // 0x1e67
    int32_t v3; // 0x1e48
    int64_t * v4; // 0x1e48
    if (v2 >= 0 == (v2 != 0)) {
        // 0x1e48
        v4 = (int64_t *)(a1 + 8);
        v3 = v2;
      lab_0x1e92:;
        int64_t * v5 = v4;
        uint64_t v6 = (int64_t)v3;
        int64_t v7 = v6 < a3 ? v6 : a3 & 0xffffffff;
        int64_t result = 0x100000000 * v7 / 0x100000000; // 0x1e9c
        memcpy(a2, (int64_t *)*v5, (int32_t)result);
        *v5 = result + *v5;
        *v1 = *v1 - (int32_t)v7;
        // 0x1eb8
        return result;
    }
    int64_t buf = a1 + 16; // 0x1e6e
    int64_t * v8 = (int64_t *)(a1 + 8);
    int64_t v9; // 0x1e48
    int32_t fd = v9; // 0x1e48
    int64_t result2; // 0x1e48
    while (true) {
        int32_t v10 = read(fd, (int64_t *)buf, 0x2000); // 0x1e7c
        *v1 = v10;
        if (v10 < 0) {
            int32_t v11 = *__errno_location(); // 0x1e62
            result2 = -1;
            if (v11 != 4) {
                // break -> 0x1eb8
                break;
            }
        } else {
            // 0x1e88
            result2 = 0;
            if (v10 == 0) {
                // break -> 0x1eb8
                break;
            }
            // 0x1e8c
            *v8 = buf;
        }
        int32_t v12 = *v1; // 0x1e67
        v4 = v8;
        v3 = v12;
        if (v12 >= 0 == (v12 != 0)) {
            goto lab_0x1e92;
        }
        // 0x1e67
        int64_t v13; // 0x1e48
        fd = *(int32_t *)&v13;
    }
    // 0x1eb8
    return result2;
}

// Address range: 0x1ed3 - 0x1f77
int64_t rio_readlineb(int64_t * a1, int64_t * a2, uint64_t a3) {
    int64_t v1 = (int64_t)a2;
    int64_t v2 = __readfsqword(40); // 0x1ee6
    int64_t v3 = 1; // 0x1efe
    int64_t v4 = v1; // 0x1efe
    int64_t result; // 0x1ed3
    if (a3 <= 1) {
        goto lab_0x1f47_2;
    } else {
        int64_t v5 = 1;
        int64_t v6 = v1;
        char v7; // bp-49, 0x1ed3
        int32_t v8 = rio_read((int64_t)a1, (int64_t *)&v7, 1);
        while (v8 == 1) {
            int64_t v9 = v6 + 1; // 0x1f17
            *(char *)v6 = v7;
            v3 = v5;
            v4 = v9;
            if (v7 == 10) {
                goto lab_0x1f47_2;
            }
            int64_t v10 = v5 + 1; // 0x1f2a
            v3 = v10;
            v4 = v9;
            if (v10 >= a3) {
                goto lab_0x1f47_2;
            }
            v5 = v10;
            v6 = v9;
            v8 = rio_read((int64_t)a1, (int64_t *)&v7, 1);
        }
        // 0x1f33
        result = -1;
        if (v8 != 0) {
            goto lab_0x1f4e;
        } else {
            // 0x1f37
            v3 = v5;
            v4 = v6;
            result = 0;
            if (v5 != 1) {
                goto lab_0x1f47_2;
            } else {
                goto lab_0x1f4e;
            }
        }
    }
  lab_0x1f47_2:
    // 0x1f47
    *(char *)v4 = 0;
    result = v3;
    goto lab_0x1f4e;
  lab_0x1f4e:
    // 0x1f4e
    if (v2 == __readfsqword(40)) {
        // 0x1f5e
        return result;
    }
    // 0x1f72
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x1f77 - 0x208a
int64_t urlencode(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x1f85
    int64_t v2 = -1; // 0x1f9c
    int64_t v3 = a1; // 0x1f9c
    int64_t v4 = 0; // 0x1f9c
    while (v2 != 0) {
        int64_t v5 = v3;
        v2--;
        bool v6; // 0x1f77
        v3 = v5 + (v6 ? -1 : 1);
        v4 = v2;
        if (*(char *)v5 == 0) {
            // break ->
            break;
        }
        v4 = 0;
    }
    int64_t v7 = 0xfffffffe - v4; // 0x1fa4
    int64_t v8 = a1; // 0x1fbe
    int64_t result = v7 & 0xffffffff; // 0x1fbe
    if ((int32_t)v7 != 0) {
        unsigned char v9 = *(char *)v8; // 0x1fc4
        int64_t v10; // 0x1f77
        char v11; // bp-40, 0x1f77
        if ((v9 & -33) < 91 || v9 < 58 || v9 == 95 || v9 == 46 || v9 == 42 || v9 == 45) {
            // 0x1fa9
            *(char *)a2 = v9;
            v10 = a2 + 1;
        } else {
            if (v9 == 32) {
                // 0x205a
                *(char *)a2 = 43;
                v10 = a2 + 1;
            } else {
                // 0x2004
                if (v9 != 9 && v9 >= 128) {
                    // break -> 0x206c
                    break;
                }
                // 0x2018
                __sprintf_chk(&v11, 1, 8, "%%%02X", (int32_t)v9);
                *(char *)a2 = v11;
                v10 = a2 + 3;
            }
        }
        int64_t v12 = v7 + 0xffffffff;
        int64_t v13 = v12 & 0xffffffff;
        v8++;
        result = v13;
        while ((int32_t)v12 != 0) {
            int64_t v14 = v10;
            v9 = *(char *)v8;
            if ((v9 & -33) < 91 || v9 < 58 || v9 == 95 || v9 == 46 || v9 == 42 || v9 == 45) {
                // 0x1fa9
                *(char *)v14 = v9;
                v10 = v14 + 1;
            } else {
                if (v9 == 32) {
                    // 0x205a
                    *(char *)v14 = 43;
                    v10 = v14 + 1;
                } else {
                    // 0x2004
                    result = 0xffffffff;
                    if (v9 != 9 && v9 >= 128) {
                        // break -> 0x206c
                        break;
                    }
                    // 0x2018
                    __sprintf_chk(&v11, 1, 8, "%%%02X", (int32_t)v9);
                    *(char *)v14 = v11;
                    v10 = v14 + 3;
                }
            }
            // 0x1fb1
            v12 = v13 + 0xffffffff;
            v13 = v12 & 0xffffffff;
            v8++;
            result = v13;
        }
    }
    // 0x206c
    if (v1 == __readfsqword(40)) {
        // 0x207c
        return result;
    }
    // 0x2085
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x208a - 0x2828
int64_t submitr(char * name, int64_t * a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int64_t a7) {
    int64_t v1 = __readfsqword(40); // 0x20ba
    int32_t v2 = 0; // bp-41068, 0x20cd
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x20e4
    int64_t result; // 0x208a
    if (sock_fd < 0) {
        // 0x239f
        *(int64_t *)a7 = 0x43203a726f727245;
        *(int64_t *)(a7 + 8) = 0x6e7520746e65696c;
        *(int64_t *)(a7 + 16) = 0x206f7420656c6261;
        *(int64_t *)(a7 + 24) = 0x7320657461657263;
        *(int32_t *)(a7 + 32) = 0x656b636f;
        *(int16_t *)(a7 + 36) = 116;
        result = 0xffffffff;
    } else {
        struct hostent * v3 = gethostbyname(name); // 0x20f6
        if (v3 == NULL) {
            // 0x23eb
            *(int64_t *)a7 = 0x44203a726f727245;
            *(int64_t *)(a7 + 8) = 0x6e7520736920534e;
            *(int64_t *)(a7 + 16) = 0x206f7420656c6261;
            *(int64_t *)(a7 + 24) = 0x2065766c6f736572;
            *(int64_t *)(a7 + 32) = 0x2062616c6f747541;
            *(int64_t *)(a7 + 40) = 0x6120726576726573;
            *(int32_t *)(a7 + 48) = 0x65726464;
            *(int16_t *)(a7 + 52) = 0x7373;
            *(char *)(a7 + 54) = 0;
            close(sock_fd);
            result = 0xffffffff;
        } else {
            int64_t v4 = (int64_t)v3; // 0x20f6
            int64_t addr = 2; // bp-41064, 0x2121
            int64_t v5 = *(int64_t *)*(int64_t *)(v4 + 24); // 0x2130
            int64_t v6; // bp-41060, 0x208a
            __memmove_chk(&v6, (int64_t *)v5, *(int32_t *)(v4 + 20), 12);
            if (connect(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
                // 0x2461
                *(int64_t *)a7 = 0x55203a726f727245;
                *(int64_t *)(a7 + 8) = 0x6f7420656c62616e;
                *(int64_t *)(a7 + 16) = 0x7463656e6e6f6320;
                *(int64_t *)(a7 + 24) = 0x20656874206f7420;
                *(int64_t *)(a7 + 32) = 0x2062616c6f747541;
                *(int32_t *)(a7 + 40) = 0x76726573;
                *(int16_t *)(a7 + 44) = 0x7265;
                *(char *)(a7 + 46) = 0;
                close(sock_fd);
                result = 0xffffffff;
            } else {
                int64_t v7 = sock_fd;
                bool v8; // 0x208a
                int64_t v9 = v8 ? -1 : 1;
                int64_t v10 = -1; // 0x2179
                int64_t v11 = a6; // 0x208a
                int64_t v12 = 0; // 0x2179
                while (v10 != 0) {
                    int64_t v13 = v11;
                    v10--;
                    v11 = v13 + v9;
                    v12 = v10;
                    if (*(char *)v13 == 0) {
                        // break ->
                        break;
                    }
                    v12 = 0;
                }
                int64_t v14 = v12;
                int64_t v15 = -1; // 0x2189
                int64_t v16 = a3; // 0x2189
                int64_t v17 = 0; // 0x2189
                while (v15 != 0) {
                    int64_t v18 = v16;
                    v15--;
                    v16 = v18 + v9;
                    v17 = v15;
                    if (*(char *)v18 == 0) {
                        // break ->
                        break;
                    }
                    v17 = 0;
                }
                int64_t v19 = -1; // 0x2197
                int64_t v20 = a4; // 0x2197
                int64_t v21 = 0; // 0x2197
                while (v19 != 0) {
                    int64_t v22 = v20;
                    v19--;
                    v20 = v22 + v9;
                    v21 = v19;
                    if (*(char *)v22 == 0) {
                        // break ->
                        break;
                    }
                    v21 = 0;
                }
                int64_t v23 = -1 - v21;
                int64_t v24 = -1; // 0x21a9
                int64_t v25 = a5; // 0x21a9
                int64_t v26 = 0; // 0x21a9
                while (v24 != 0) {
                    int64_t v27 = v25;
                    v24--;
                    v25 = v27 + v9;
                    v26 = v24;
                    if (*(char *)v27 == 0) {
                        // break ->
                        break;
                    }
                    v26 = 0;
                }
                if (120 - v14 + (2 * v14 ^ -2) - v17 + v23 + -1 - v26 < 0x2001) {
                    // 0x21cf
                    int64_t v28; // bp-24648, 0x208a
                    __asm_rep_stosq_memset((char *)&v28, 0, (int64_t)&g19);
                    if ((int32_t)urlencode(a6, (int64_t)&v28) < 0) {
                        // 0x253c
                        *(int64_t *)a7 = 0x52203a726f727245;
                        *(int64_t *)(a7 + 8) = 0x747320746c757365;
                        *(int64_t *)(a7 + 16) = 0x6e6f6320676e6972;
                        *(int64_t *)(a7 + 24) = 0x6e6120736e696174;
                        *(int64_t *)(a7 + 32) = 0x6c6167656c6c6920;
                        *(int64_t *)(a7 + 40) = 0x72706e7520726f20;
                        *(int64_t *)(a7 + 48) = 0x20656c6261746e69;
                        *(int64_t *)(a7 + 56) = 0x6574636172616863;
                        *(int16_t *)(a7 + 64) = (int16_t)"ut string is too large.";
                        *(char *)(a7 + 66) = 0;
                        close(sock_fd);
                        result = 0xffffffff;
                    } else {
                        // 0x21f7
                        int64_t str; // bp-32840, 0x208a
                        __sprintf_chk((char *)&str, 1, 0x2000, "GET /courses/%s/assessments/%s/log_submit?user=%s&assessment=&result=%s HTTP/1.0\r\nHost: %s\r\n\r\n", (char *)a3, (char *)a5, (char *)a4, &v28, name);
                        int64_t v29 = &str; // 0x2244
                        int64_t v30 = -1; // 0x2247
                        int64_t v31 = v29; // 0x2247
                        int64_t v32 = 0; // 0x2247
                        while (v30 != 0) {
                            int64_t v33 = v31;
                            v30--;
                            v31 = v33 + v9;
                            v32 = v30;
                            if (*(char *)v33 == 0) {
                                // break ->
                                break;
                            }
                            v32 = 0;
                        }
                        if (rio_writen(v7, &str, -2 - v32) < 0) {
                            // 0x25c7
                            *(int64_t *)a7 = 0x43203a726f727245;
                            *(int64_t *)(a7 + 8) = 0x6e7520746e65696c;
                            *(int64_t *)(a7 + 16) = 0x206f7420656c6261;
                            *(int64_t *)(a7 + 24) = 0x6f74206574697277;
                            *(int64_t *)(a7 + 32) = 0x7475412065687420;
                            *(int64_t *)(a7 + 40) = 0x7265732062616c6f;
                            *(int32_t *)(a7 + 48) = 0x726576;
                            close(sock_fd);
                            result = 0xffffffff;
                        } else {
                            // 0x226a
                            int64_t v34; // bp-41048, 0x208a
                            rio_readinitb(&v34, v7);
                            if (rio_readlineb(&v34, &str, 0x2000) < 1) {
                                // 0x2633
                                *(int64_t *)a7 = 0x43203a726f727245;
                                *(int64_t *)(a7 + 8) = 0x6e7520746e65696c;
                                *(int64_t *)(a7 + 16) = 0x206f7420656c6261;
                                *(int64_t *)(a7 + 24) = 0x7269662064616572;
                                *(int64_t *)(a7 + 32) = 0x6564616568207473;
                                *(int64_t *)(a7 + 40) = 0x41206d6f72662072;
                                *(int64_t *)(a7 + 48) = 0x732062616c6f7475;
                                *(int32_t *)(a7 + 56) = 0x65767265;
                                *(int16_t *)(a7 + 60) = 114;
                                close(sock_fd);
                                result = 0xffffffff;
                            } else {
                                // 0x2297
                                int64_t v35; // bp-16456, 0x208a
                                int64_t v36; // bp-8264, 0x208a
                                sscanf((char *)&str, "%s %d %[a-zA-z ]", &v35, &v2, &v36);
                                int64_t v37 = 3; // 0x22d9
                                int64_t v38 = v29;
                                int64_t v39 = (int64_t)"\r\n";
                                unsigned char v40 = *(char *)v38; // 0x22d9
                                char v41 = *(char *)v39; // 0x22d9
                                char v42 = v41; // 0x22d9
                                bool v43 = false; // 0x22d9
                                int64_t v44; // 0x208a
                                int64_t v45; // 0x208a
                                while (v40 == v41) {
                                    v37--;
                                    v44 = v39 + v9;
                                    v45 = v38 + v9;
                                    v42 = v40;
                                    v43 = true;
                                    if (v37 == 0) {
                                        // break ->
                                        break;
                                    }
                                    v38 = v45;
                                    v39 = v44;
                                    v40 = *(char *)v38;
                                    v41 = *(char *)v39;
                                    v42 = v41;
                                    v43 = false;
                                }
                                unsigned char v46 = v42;
                                int64_t v47 = rio_readlineb(&v34, &str, 0x2000);
                                while ((v40 >= v46 && !v43) != v40 < v46) {
                                    if (v47 >= 0 != v47 != 0) {
                                        // 0x2304
                                        *(int64_t *)a7 = 0x43203a726f727245;
                                        *(int64_t *)(a7 + 8) = 0x6e7520746e65696c;
                                        *(int64_t *)(a7 + 16) = 0x206f7420656c6261;
                                        *(int64_t *)(a7 + 24) = 0x6165682064616572;
                                        *(int64_t *)(a7 + 32) = 0x6f72662073726564;
                                        *(int64_t *)(a7 + 40) = 0x616c6f747541206d;
                                        *(int64_t *)(a7 + 48) = 0x7265767265732062;
                                        *(char *)(a7 + 56) = 0;
                                        close(sock_fd);
                                        result = 0xffffffff;
                                        goto lab_0x2376;
                                    }
                                    v37 = 3;
                                    v38 = v29;
                                    v39 = (int64_t)"\r\n";
                                    v40 = *(char *)v38;
                                    v41 = *(char *)v39;
                                    v42 = v41;
                                    v43 = false;
                                    while (v40 == v41) {
                                        v37--;
                                        v44 = v39 + v9;
                                        v45 = v38 + v9;
                                        v42 = v40;
                                        v43 = true;
                                        if (v37 == 0) {
                                            // break ->
                                            break;
                                        }
                                        v38 = v45;
                                        v39 = v44;
                                        v40 = *(char *)v38;
                                        v41 = *(char *)v39;
                                        v42 = v41;
                                        v43 = false;
                                    }
                                    v46 = v42;
                                    v47 = rio_readlineb(&v34, &str, 0x2000);
                                }
                                if (v47 < 1) {
                                    // 0x2769
                                    *(int64_t *)a7 = 0x43203a726f727245;
                                    *(int64_t *)(a7 + 8) = 0x6e7520746e65696c;
                                    *(int64_t *)(a7 + 16) = 0x206f7420656c6261;
                                    *(int64_t *)(a7 + 24) = 0x6174732064616572;
                                    *(int64_t *)(a7 + 32) = 0x7373656d20737574;
                                    *(int64_t *)(a7 + 40) = 0x6d6f726620656761;
                                    *(int64_t *)(a7 + 48) = 0x62616c6f74754120;
                                    *(int64_t *)(a7 + 56) = 0x72657672657320;
                                    close(sock_fd);
                                    result = 0xffffffff;
                                } else {
                                    char * str2 = (char *)a7;
                                    if (v2 != 200) {
                                        // 0x27ea
                                        __sprintf_chk(str2, 1, -1, "Error: HTTP request failed with error %d: %s", (int64_t)v2, &v36);
                                        close(sock_fd);
                                        result = 0xffffffff;
                                    } else {
                                        // 0x26e5
                                        strcpy(str2, (char *)&str);
                                        close(sock_fd);
                                        int64_t v48 = (int64_t)"OK\n"; // 0x208a
                                        int64_t v49 = a7; // 0x208a
                                        int64_t v50 = 4; // 0x270b
                                        unsigned char v51 = *(char *)v49; // 0x270b
                                        char v52 = *(char *)v48; // 0x270b
                                        char v53 = v52; // 0x270b
                                        bool v54 = false; // 0x270b
                                        while (v51 == v52) {
                                            v50--;
                                            v48 += v9;
                                            v49 += v9;
                                            v53 = v51;
                                            v54 = true;
                                            if (v50 == 0) {
                                                // break ->
                                                break;
                                            }
                                            v51 = *(char *)v49;
                                            v52 = *(char *)v48;
                                            v53 = v52;
                                            v54 = false;
                                        }
                                        unsigned char v55 = v53;
                                        int64_t v56 = (int64_t)!((v51 < v55 | v54)) - (int64_t)(v51 < v55); // 0x2710
                                        result = v56;
                                        int64_t v57 = (int64_t)"OK\r\n"; // 0x2717
                                        int64_t v58 = a7; // 0x2717
                                        int64_t v59 = 5; // 0x2717
                                        if ((int32_t)v56 != 0) {
                                            unsigned char v60 = *(char *)v58; // 0x272c
                                            char v61 = *(char *)v57; // 0x272c
                                            char v62 = v61; // 0x272c
                                            bool v63 = false; // 0x272c
                                            while (v60 == v61) {
                                                int64_t v64 = v59 - 1; // 0x272c
                                                v57 += v9;
                                                v58 += v9;
                                                v59 = v64;
                                                v62 = v60;
                                                v63 = true;
                                                if (v64 == 0) {
                                                    // break ->
                                                    break;
                                                }
                                                v60 = *(char *)v58;
                                                v61 = *(char *)v57;
                                                v62 = v61;
                                                v63 = false;
                                            }
                                            unsigned char v65 = v62;
                                            int64_t v66 = (int64_t)!((v60 < v65 | v63)) - (int64_t)(v60 < v65); // 0x2731
                                            result = v66;
                                            int64_t v67 = (int64_t)"OK"; // 0x2738
                                            int64_t v68 = a7; // 0x2738
                                            int64_t v69 = 3; // 0x2738
                                            if ((int32_t)v66 != 0) {
                                                unsigned char v70 = *(char *)v68; // 0x274d
                                                char v71 = *(char *)v67; // 0x274d
                                                char v72 = v71; // 0x274d
                                                bool v73 = false; // 0x274d
                                                while (v70 == v71) {
                                                    int64_t v74 = v69 - 1; // 0x274d
                                                    v67 += v9;
                                                    v68 += v9;
                                                    v69 = v74;
                                                    v72 = v70;
                                                    v73 = true;
                                                    if (v74 == 0) {
                                                        // break ->
                                                        break;
                                                    }
                                                    v70 = *(char *)v68;
                                                    v71 = *(char *)v67;
                                                    v72 = v71;
                                                    v73 = false;
                                                }
                                                unsigned char v75 = v72;
                                                int64_t v76 = (int64_t)!((v70 < v75 | v73)) - (int64_t)(v70 < v75); // 0x2752
                                                result = (int32_t)v76 == 0 ? v76 : 0xffffffff;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // 0x24c9
                    *(int64_t *)a7 = 0x52203a726f727245;
                    *(int64_t *)(a7 + 8) = 0x747320746c757365;
                    *(int64_t *)(a7 + 16) = 0x6f6f7420676e6972;
                    *(int64_t *)(a7 + 24) = 0x202e656772616c20;
                    *(int64_t *)(a7 + 32) = 0x6573616572636e49;
                    *(int64_t *)(a7 + 40) = 0x5254494d42555320;
                    *(int64_t *)(a7 + 48) = 0x46554258414d5f;
                    close(sock_fd);
                    result = 0xffffffff;
                }
            }
        }
    }
    goto lab_0x2376;
  lab_0x2376:
    // 0x2376
    if (v1 == __readfsqword(40)) {
        // 0x238d
        return result;
    }
    // 0x2823
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x2828 - 0x2856
int64_t init_timeout(int64_t a1) {
    int32_t v1 = a1; // 0x2828
    if (v1 == 0) {
        // 0x2854
        int64_t result; // 0x2828
        return result;
    }
    // 0x282c
    signal(SIGALARM, 0x1dba);
    return alarm(v1 > 0 ? v1 : 0);
}

// Address range: 0x2856 - 0x2a81
int64_t init_driver(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = __readfsqword(40); // 0x2861
    signal(SIGPIPE, SIG_IGN);
    signal(SIGINFO, SIG_IGN);
    signal(SIGINFO, SIG_IGN);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x28ad
    int64_t result; // 0x2856
    if (sock_fd < 0) {
        // 0x295d
        *a1 = 0x43203a726f727245;
        *(int64_t *)(v1 + 8) = 0x6e7520746e65696c;
        *(int64_t *)(v1 + 16) = 0x206f7420656c6261;
        *(int64_t *)(v1 + 24) = 0x7320657461657263;
        *(int32_t *)(v1 + 32) = 0x656b636f;
        *(int16_t *)(v1 + 36) = 116;
        result = 0xffffffff;
    } else {
        struct hostent * v3 = gethostbyname("192.168.232.160"); // 0x28c3
        if (v3 == NULL) {
            // 0x29b0
            *a1 = 0x44203a726f727245;
            *(int64_t *)(v1 + 8) = 0x6e7520736920534e;
            *(int64_t *)(v1 + 16) = 0x206f7420656c6261;
            *(int64_t *)(v1 + 24) = 0x2065766c6f736572;
            *(int64_t *)(v1 + 32) = 0x6120726576726573;
            *(int32_t *)(v1 + 40) = 0x65726464;
            *(int16_t *)(v1 + 44) = 0x7373;
            *(char *)(v1 + 46) = 0;
            close(sock_fd);
            result = 0xffffffff;
        } else {
            int64_t v4 = (int64_t)v3; // 0x28c3
            int64_t addr = 2; // bp-56, 0x28ea
            int64_t v5 = *(int64_t *)*(int64_t *)(v4 + 24); // 0x28f8
            int64_t v6; // bp-52, 0x2856
            __memmove_chk(&v6, (int64_t *)v5, *(int32_t *)(v4 + 20), 12);
            if (connect(sock_fd, (struct sockaddr *)&addr, 16) < 0) {
                // 0x2a22
                *a1 = 0x55203a726f727245;
                *(int64_t *)(v1 + 8) = 0x6f7420656c62616e;
                *(int64_t *)(v1 + 16) = 0x7463656e6e6f6320;
                *(int64_t *)(v1 + 24) = 0x76726573206f7420;
                *(int16_t *)(v1 + 32) = 0x7265;
                *(char *)(v1 + 34) = 0;
                close(sock_fd);
                result = 0xffffffff;
            } else {
                // 0x2927
                close(sock_fd);
                *(int16_t *)a1 = 0x4b4f;
                *(char *)(v1 + 2) = 0;
                result = 0;
            }
        }
    }
    // 0x2940
    if (v2 == __readfsqword(40)) {
        // 0x2954
        return result;
    }
    // 0x2a7c
    __stack_chk_fail();
    return &g21;
}

// Address range: 0x2a81 - 0x2af4
int64_t driver_post(char * a1, char * a2, char * a3, int64_t * a4, int64_t a5, int64_t * a6) {
    int64_t v1 = (int64_t)a6;
    if ((int32_t)a5 != 0) {
        // 0x2aa2
        __printf_chk(1, "\nAUTORESULT_STRING=%s\n", a4);
        *(int16_t *)a6 = 0x4b4f;
        *(char *)(v1 + 2) = 0;
        // 0x2aa0
        return 0;
    }
    int64_t v2 = (int64_t)a1;
    int64_t result; // 0x2a81
    if (a1 != NULL == ((char)v2 != 0)) {
        int64_t v3 = submitr("192.168.232.160", &g20, (int64_t)a2, v2, (int64_t)a3, (int64_t)a4, v1); // 0x2ae9
        result = v3;
    } else {
        // 0x2a94
        *(int16_t *)a6 = 0x4b4f;
        *(char *)(v1 + 2) = 0;
        result = a5 & 0xffffffff;
    }
    // 0x2aa0
    return result;
}

// Address range: 0x2b00 - 0x2b65
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = _init(); // 0x2b2c
    if ((int64_t)&g2 - (int64_t)&g1 >> 3 == 0) {
        // 0x2b56
        return result;
    }
    int64_t v1 = 0; // 0x2b34
    while (v1 + 1 != (int64_t)&g2 - (int64_t)&g1 >> 3) {
        // 0x2b40
        v1++;
    }
    // 0x2b56
    return result;
}

// Address range: 0x2b70 - 0x2b72
int64_t __libc_csu_fini(void) {
    // 0x2b70
    int64_t result; // 0x2b70
    return result;
}

// Address range: 0x2b74 - 0x2b7d
int64_t _fini(void) {
    // 0x2b74
    int64_t result; // 0x2b74
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// void __cxa_finalize(void * d);
// int * __errno_location(void);
// int __fprintf_chk(FILE * restrict stream, int flag, const char * restrict format, ...);
// void __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// void * __memmove_chk(void * dest, const void * src, size_t len, size_t dstlen);
// int __printf_chk(int flag, const char * restrict format, ...);
// int __sprintf_chk(char * restrict s, int flag, size_t slen, const char * restrict format, ...);
// void __stack_chk_fail(void);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// int connect(int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
// void exit(int status);
// int fflush(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// char * getenv(const char * name);
// struct hostent * gethostbyname(const char * name);
// int gethostname(char * name, size_t len);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int puts(const char * s);
// ssize_t read(int fd, void * buf, size_t nbytes);
// __sighandler_t signal(int sig, __sighandler_t handler);
// unsigned int sleep(unsigned int seconds);
// int socket(int domain, int type, int protocol);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// int strcasecmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.5.0)
// Detected language: C
// Detected functions: 71
